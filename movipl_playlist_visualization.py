# -*- coding: utf-8 -*-
"""MoviPL-Playlist-Visualization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7Uhi9aMnUSEK4P86cnGtUnSRQpGmciP
"""

# ===================================================================
# âš™ï¸ 1. í™˜ê²½ ì„¤ì • ë° ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜
# ===================================================================
# í”„ë¡œì íŠ¸ì— í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤.
!pip install requests spotipy openai

# â¬‡ï¸ (ìµœì´ˆ 1íšŒ ì‹¤í–‰) í•œê¸€ í°íŠ¸ ì„¤ì¹˜ í›„, [ëŸ°íƒ€ì„] > [ëŸ°íƒ€ì„ ë‹¤ì‹œ ì‹œì‘]ì„ ê¼­ í•´ì£¼ì„¸ìš”! â¬‡ï¸
!sudo apt-get -y install fonts-nanum*
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

# ===================================================================
# ğŸ”‘ 2. API Key ë³´ì•ˆ ê´€ë¦¬
# ===================================================================
# [ì¤‘ìš”!] ì½”ë© ì¢Œì¸¡ì˜ ì—´ì‡ (ğŸ”‘) ì•„ì´ì½˜ì„ ëˆŒëŸ¬ ì•„ë˜ ì´ë¦„ìœ¼ë¡œ Keyë¥¼ ì €ì¥í•´ì£¼ì„¸ìš”.
# - TMDB_API_KEY, OPENAI_API_KEY, SPOTIFY_CLIENT_ID,
# - SPOTIFY_CLIENT_SECRET, SPOTIFY_REDIRECT_URI
# ===================================================================

# --- ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ë³´ì•ˆ ë¹„ë°€ ê°€ì ¸ì˜¤ê¸° ---
from google.colab import userdata
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import requests
import openai
import json
import os
from PIL import Image, ImageDraw, ImageFont
import io
from datetime import datetime
import re

class MoviPL_Visualizer:
    """
    ì˜í™”ì˜ ë¶„ìœ„ê¸°ì— ë§ëŠ” í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ê³ ,
    ê²°ê³¼ë¥¼ ë¯¸í•™ì ì¸ í…œí”Œë¦¿ ì´ë¯¸ì§€ë¡œ ì‹œê°í™”í•˜ëŠ” MoviPL ì—”ì§„ í´ë˜ìŠ¤.
    """
    def __init__(self):
        self.tmdb_api_key = None
        self.sp = None
        self.is_ready = False
        self._setup_keys()
        if self.tmdb_api_key and openai.api_key:
            self.sp = self._get_spotify_client()
            if self.sp:
                self.is_ready = True

    def _setup_keys(self):
        try:
            self.tmdb_api_key = userdata.get('TMDB_API_KEY')
            openai.api_key = userdata.get('OPENAI_API_KEY')
            print("âœ… TMDB ë° OpenAI API Key ë¡œë”© ì„±ê³µ!")
        except Exception as e:
            print(f"âŒ API Key ë¡œë”© ì‹¤íŒ¨. ì½”ë© 'ë³´ì•ˆ ë¹„ë°€' ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”. ì˜¤ë¥˜: {e}")

    def _get_spotify_client(self):
        try:
            client_id = userdata.get('SPOTIFY_CLIENT_ID')
            client_secret = userdata.get('SPOTIFY_CLIENT_SECRET')
            redirect_uri = userdata.get('SPOTIFY_REDIRECT_URI')
            auth_manager = SpotifyOAuth(client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, scope="", open_browser=False)
            auth_url = auth_manager.get_authorize_url()
            print("\n--- Spotify ìˆ˜ë™ ì¸ì¦ ì ˆì°¨ ---")
            print("1. ì•„ë˜ URLì— ì ‘ì†í•˜ì—¬ ê¶Œí•œì— ë™ì˜í•˜ì„¸ìš”.")
            print(f"ì¸ì¦ URL: {auth_url}")
            print("\n2. ê¶Œí•œ ë™ì˜ í›„ 'ì—°ê²°í•  ìˆ˜ ì—†ìŒ' í˜ì´ì§€ì˜ ì „ì²´ URLì„ ë³µì‚¬í•˜ì—¬ ì•„ë˜ì— ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš”.")
            redirected_url = input("ë¦¬ë””ë ‰ì…˜ëœ URLì„ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”: ")
            code = auth_manager.parse_response_code(redirected_url)
            token_info = auth_manager.get_access_token(code, as_dict=False)
            sp = spotipy.Spotify(auth=token_info)
            print("\nâœ… Spotify ì¸ì¦ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤!")
            return sp
        except Exception as e:
            print(f"\nâŒ Spotify ì¸ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì˜¤ë¥˜: {e}")
            return None

    def _get_movie_data(self, movie_title):
        """TMDBì—ì„œ ì˜í™” ì¤„ê±°ë¦¬ì™€ ì¥ë¥´ë¥¼ ê°€ì ¸ì˜¨ë‹¤."""
        print(f"\n--- 1. TMDBì—ì„œ '{movie_title}' ì˜í™” ì •ë³´ ê²€ìƒ‰ ---")
        search_url = f"https://api.themoviedb.org/3/search/movie?api_key={self.tmdb_api_key}&query={movie_title}&language=ko-KR"
        genre_url = f"https://api.themoviedb.org/3/genre/movie/list?api_key={self.tmdb_api_key}&language=ko-KR"
        try:
            genre_response = requests.get(genre_url)
            genre_response.raise_for_status()
            genre_dict = {genre['id']: genre['name'] for genre in genre_response.json()['genres']}
            response = requests.get(search_url)
            response.raise_for_status()
            search_results = response.json().get('results')
            if not search_results:
                print(f"-> ì˜¤ë¥˜: '{movie_title}'ì— ëŒ€í•œ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")
                return None, None
            movie = search_results[0]
            genre_names = [genre_dict.get(gid) for gid in movie.get('genre_ids', []) if genre_dict.get(gid)]
            print(f"-> ì˜í™” ê²€ìƒ‰ ì™„ë£Œ! (ì¥ë¥´: {', '.join(genre_names)})")
            return movie.get('overview'), genre_names
        except requests.exceptions.RequestException as e:
            print(f"-> TMDB API ì˜¤ë¥˜: {e}")
            return None, None

    def _get_llm_keywords(self, overview, genres):
        """LLMì„ í†µí•´ ì˜í™”ì˜ ê°ì„± ë° ì¥ë¥´ í‚¤ì›Œë“œë¥¼ ì¶”ì¶œí•œë‹¤."""
        print("--- 2. LLM(ì‹œë„¤ë§ˆí‹± íë ˆì´í„°)ìœ¼ë¡œ í‚¤ì›Œë“œ ì¶”ì¶œ ---")
        if not overview: return []
        prompt = f"""ë‹¹ì‹ ì€ ì˜í™”ì˜ ì„œì‚¬ì™€ ì¥ë¥´ë¥¼ ë¶„ì„í•˜ì—¬ ê·¸ í•µì‹¬ ë¶„ìœ„ê¸°ë¥¼ ìŒì•…ì  í‚¤ì›Œë“œë¡œ ì—°ê²°í•˜ëŠ” ìµœê³ ì˜ 'ì‹œë„¤ë§ˆí‹± íë ˆì´í„°'ì…ë‹ˆë‹¤.
        ì•„ë˜ ì˜í™” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ, ìŒì•…ì„ ì°¾ëŠ” ë° ì‚¬ìš©í•  ì˜ì–´ í‚¤ì›Œë“œ 5ê°œë¥¼ JSON ë¦¬ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ ì¶”ì¶œí•´ì£¼ì„¸ìš”.
        - ì˜í™” ì¥ë¥´: {", ".join(genres)}
        - ì˜í™” ì¤„ê±°ë¦¬: {overview}"""
        try:
            response = openai.chat.completions.create(model="gpt-3.5-turbo", messages=[{"role": "system", "content": "You are a cinematic music curator."}, {"role": "user", "content": prompt}], response_format={"type": "json_object"})
            result_text = response.choices[0].message.content
            keywords = list(json.loads(result_text).values())[0]
            print(f"-> ì¶”ì¶œëœ íë ˆì´ì…˜ í‚¤ì›Œë“œ: {keywords}")
            return keywords
        except Exception as e:
            print(f"-> OpenAI API ì˜¤ë¥˜: {e}")
            return []

    def _recommend_music(self, keywords):
        """ì¶”ì¶œëœ í‚¤ì›Œë“œë¡œ Spotifyì—ì„œ ìŒì•…ì„ ê²€ìƒ‰í•˜ê³  ì¤‘ë³µì„ ì œê±°í•˜ì—¬ ì¶”ì²œí•œë‹¤."""
        print("--- 3. íë ˆì´ì…˜ í‚¤ì›Œë“œë¡œ Spotify ìŒì•… ì¶”ì²œ ---")
        if not keywords: return []
        try:
            query = " ".join(keywords)
            results = self.sp.search(q=query, type='track', limit=20, market="KR")
            unique_tracks, seen_normalized_titles = [], set()
            for track in results.get('tracks', {}).get('items', []):
                title = track.get('name')
                normalized_title = re.split(r'\(|-', title)[0].strip().lower()
                if normalized_title in seen_normalized_titles: continue
                unique_tracks.append(track)
                seen_normalized_titles.add(normalized_title)
                if len(unique_tracks) >= 6: break
            return unique_tracks
        except Exception as e:
            print(f"-> Spotify API ì˜¤ë¥˜: {e}")
            return []

    def _create_playlist_template(self, movie_title, recommended_tracks):
        """Pillowë¥¼ ì‚¬ìš©í•˜ì—¬ í•€í„°ë ˆìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ì˜ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ í…œí”Œë¦¿ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•œë‹¤."""
        print("--- 4. Pillowë¡œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ í…œí”Œë¦¿ ì´ë¯¸ì§€ ìƒì„± ---")
        try:
            font_header = ImageFont.truetype("/usr/share/fonts/truetype/nanum/NanumSquareB.ttf", 50)
            font_title = ImageFont.truetype("/usr/share/fonts/truetype/nanum/NanumSquareB.ttf", 22)
            font_artist = ImageFont.truetype("/usr/share/fonts/truetype/nanum/NanumSquareR.ttf", 18)
        except IOError:
            print("-> ë‚˜ëˆ” í°íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ í°íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.")
            font_header, font_title, font_artist = [ImageFont.load_default()] * 3

        img = Image.new("RGB", (1024, 1280), (245, 245, 245))
        draw = ImageDraw.Draw(img)
        header_text = f"Playlist for <{movie_title}>"
        draw.text((50, 50), header_text, font=font_header, fill=(50, 50, 50))

        cols, rows = 3, 2
        padding = 50
        card_width = (img.width - padding * (cols + 1)) / cols
        card_height = (img.height - 250 - padding * (rows + 1)) / rows

        for i, track in enumerate(recommended_tracks):
            row, col = i // cols, i % cols
            x = padding + col * (card_width + padding)
            y = 200 + row * (card_height + padding)

            draw.rectangle([x, y, x + card_width, y + card_height], fill=(255, 255, 255), outline=(220, 220, 220), width=2)

            art_x, art_y = x + 20, y + 20
            art_size = card_width - 40
            try:
                album_art_url = track['album']['images'][0]['url']
                art_response = requests.get(album_art_url)
                album_art_img = Image.open(io.BytesIO(art_response.content)).resize((int(art_size), int(art_size)))
                img.paste(album_art_img, (int(art_x), int(art_y)))
            except:
                draw.rectangle([art_x, art_y, art_x + art_size, art_y + art_size], fill=(230, 230, 230))

            text_x, text_y = x + 20, art_y + art_size + 20
            title_text = track['name']
            artist_text = ", ".join([a['name'] for a in track['artists']])
            if len(title_text) > 20: title_text = title_text[:20] + "..."
            if len(artist_text) > 25: artist_text = artist_text[:25] + "..."
            draw.text((text_x, text_y), title_text, font=font_title, fill=(30, 30, 30))
            draw.text((text_x, text_y + 30), artist_text, font=font_artist, fill=(120, 120, 120))

            ui_y = y + card_height - 50
            draw.line([x + 20, ui_y, x + card_width - 20, ui_y], fill=(220, 220, 220), width=3)
            draw.polygon([(x + 120, ui_y + 15), (x + 120, ui_y + 35), (x + 140, ui_y + 25)], fill=(80, 80, 80))

        print("-> í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ í…œí”Œë¦¿ ìƒì„± ì™„ë£Œ!")
        return img

    def run(self):
        """ì‚¬ìš©ìì™€ ìƒí˜¸ì‘ìš©í•˜ë©° ì˜í™” í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ì™€ ì•„íŠ¸ì›Œí¬ë¥¼ ìƒì„±í•œë‹¤."""
        movie_title = input("\ní”Œë ˆì´ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  ì‹¶ì€ ì˜í™” ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”: ")
        if not movie_title:
            print("-> ì˜í™” ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
            return

        overview, genres = self._get_movie_data(movie_title)
        if not overview: return

        keywords = self._get_llm_keywords(overview, genres)
        if not keywords: return

        recommended_tracks = self._recommend_music(keywords)

        print("\nâœ¨ ìµœì¢… ì¶”ì²œ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ âœ¨")
        if not recommended_tracks:
            print("-> ì¶”ì²œí•  ë§Œí•œ ê³¡ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            return

        for i, track in enumerate(recommended_tracks):
            artist_names = ", ".join([a['name'] for a in track['artists']])
            print(f"  {i+1}. {track['name']} - {artist_names}")

        final_image = self._create_playlist_template(movie_title, recommended_tracks)
        if final_image:
            print("\nğŸ¨ ìƒì„±ëœ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì´ë¯¸ì§€ ğŸ¨")
            display(final_image)

# --- ë©”ì¸ ì‹¤í–‰ ë¶€ë¶„ ---
if __name__ == "__main__":
    movipl_engine = MoviPL_Visualizer()
    if movipl_engine.is_ready:
        movipl_engine.run()