# -*- coding: utf-8 -*-
"""MoviPL-Playlist-Visualization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e7Uhi9aMnUSEK4P86cnGtUnSRQpGmciP
"""

# ===================================================================
# ⚙️ 1. 환경 설정 및 라이브러리 설치
# ===================================================================
# 프로젝트에 필요한 라이브러리를 설치합니다.
!pip install requests spotipy openai

# ⬇️ (최초 1회 실행) 한글 폰트 설치 후, [런타임] > [런타임 다시 시작]을 꼭 해주세요! ⬇️
!sudo apt-get -y install fonts-nanum*
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

# ===================================================================
# 🔑 2. API Key 보안 관리
# ===================================================================
# [중요!] 코랩 좌측의 열쇠(🔑) 아이콘을 눌러 아래 이름으로 Key를 저장해주세요.
# - TMDB_API_KEY, OPENAI_API_KEY, SPOTIFY_CLIENT_ID,
# - SPOTIFY_CLIENT_SECRET, SPOTIFY_REDIRECT_URI
# ===================================================================

# --- 라이브러리 및 보안 비밀 가져오기 ---
from google.colab import userdata
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import requests
import openai
import json
import os
from PIL import Image, ImageDraw, ImageFont
import io
from datetime import datetime
import re

class MoviPL_Visualizer:
    """
    영화의 분위기에 맞는 플레이리스트를 생성하고,
    결과를 미학적인 템플릿 이미지로 시각화하는 MoviPL 엔진 클래스.
    """
    def __init__(self):
        self.tmdb_api_key = None
        self.sp = None
        self.is_ready = False
        self._setup_keys()
        if self.tmdb_api_key and openai.api_key:
            self.sp = self._get_spotify_client()
            if self.sp:
                self.is_ready = True

    def _setup_keys(self):
        try:
            self.tmdb_api_key = userdata.get('TMDB_API_KEY')
            openai.api_key = userdata.get('OPENAI_API_KEY')
            print("✅ TMDB 및 OpenAI API Key 로딩 성공!")
        except Exception as e:
            print(f"❌ API Key 로딩 실패. 코랩 '보안 비밀' 설정을 확인해주세요. 오류: {e}")

    def _get_spotify_client(self):
        try:
            client_id = userdata.get('SPOTIFY_CLIENT_ID')
            client_secret = userdata.get('SPOTIFY_CLIENT_SECRET')
            redirect_uri = userdata.get('SPOTIFY_REDIRECT_URI')
            auth_manager = SpotifyOAuth(client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri, scope="", open_browser=False)
            auth_url = auth_manager.get_authorize_url()
            print("\n--- Spotify 수동 인증 절차 ---")
            print("1. 아래 URL에 접속하여 권한에 동의하세요.")
            print(f"인증 URL: {auth_url}")
            print("\n2. 권한 동의 후 '연결할 수 없음' 페이지의 전체 URL을 복사하여 아래에 붙여넣어 주세요.")
            redirected_url = input("리디렉션된 URL을 여기에 붙여넣으세요: ")
            code = auth_manager.parse_response_code(redirected_url)
            token_info = auth_manager.get_access_token(code, as_dict=False)
            sp = spotipy.Spotify(auth=token_info)
            print("\n✅ Spotify 인증에 성공했습니다!")
            return sp
        except Exception as e:
            print(f"\n❌ Spotify 인증 중 오류가 발생했습니다. 오류: {e}")
            return None

    def _get_movie_data(self, movie_title):
        """TMDB에서 영화 줄거리와 장르를 가져온다."""
        print(f"\n--- 1. TMDB에서 '{movie_title}' 영화 정보 검색 ---")
        search_url = f"https://api.themoviedb.org/3/search/movie?api_key={self.tmdb_api_key}&query={movie_title}&language=ko-KR"
        genre_url = f"https://api.themoviedb.org/3/genre/movie/list?api_key={self.tmdb_api_key}&language=ko-KR"
        try:
            genre_response = requests.get(genre_url)
            genre_response.raise_for_status()
            genre_dict = {genre['id']: genre['name'] for genre in genre_response.json()['genres']}
            response = requests.get(search_url)
            response.raise_for_status()
            search_results = response.json().get('results')
            if not search_results:
                print(f"-> 오류: '{movie_title}'에 대한 검색 결과가 없습니다.")
                return None, None
            movie = search_results[0]
            genre_names = [genre_dict.get(gid) for gid in movie.get('genre_ids', []) if genre_dict.get(gid)]
            print(f"-> 영화 검색 완료! (장르: {', '.join(genre_names)})")
            return movie.get('overview'), genre_names
        except requests.exceptions.RequestException as e:
            print(f"-> TMDB API 오류: {e}")
            return None, None

    def _get_llm_keywords(self, overview, genres):
        """LLM을 통해 영화의 감성 및 장르 키워드를 추출한다."""
        print("--- 2. LLM(시네마틱 큐레이터)으로 키워드 추출 ---")
        if not overview: return []
        prompt = f"""당신은 영화의 서사와 장르를 분석하여 그 핵심 분위기를 음악적 키워드로 연결하는 최고의 '시네마틱 큐레이터'입니다.
        아래 영화 정보를 바탕으로, 음악을 찾는 데 사용할 영어 키워드 5개를 JSON 리스트 형식으로 추출해주세요.
        - 영화 장르: {", ".join(genres)}
        - 영화 줄거리: {overview}"""
        try:
            response = openai.chat.completions.create(model="gpt-3.5-turbo", messages=[{"role": "system", "content": "You are a cinematic music curator."}, {"role": "user", "content": prompt}], response_format={"type": "json_object"})
            result_text = response.choices[0].message.content
            keywords = list(json.loads(result_text).values())[0]
            print(f"-> 추출된 큐레이션 키워드: {keywords}")
            return keywords
        except Exception as e:
            print(f"-> OpenAI API 오류: {e}")
            return []

    def _recommend_music(self, keywords):
        """추출된 키워드로 Spotify에서 음악을 검색하고 중복을 제거하여 추천한다."""
        print("--- 3. 큐레이션 키워드로 Spotify 음악 추천 ---")
        if not keywords: return []
        try:
            query = " ".join(keywords)
            results = self.sp.search(q=query, type='track', limit=20, market="KR")
            unique_tracks, seen_normalized_titles = [], set()
            for track in results.get('tracks', {}).get('items', []):
                title = track.get('name')
                normalized_title = re.split(r'\(|-', title)[0].strip().lower()
                if normalized_title in seen_normalized_titles: continue
                unique_tracks.append(track)
                seen_normalized_titles.add(normalized_title)
                if len(unique_tracks) >= 6: break
            return unique_tracks
        except Exception as e:
            print(f"-> Spotify API 오류: {e}")
            return []

    def _create_playlist_template(self, movie_title, recommended_tracks):
        """Pillow를 사용하여 핀터레스트 스타일의 플레이리스트 템플릿 이미지를 생성한다."""
        print("--- 4. Pillow로 플레이리스트 템플릿 이미지 생성 ---")
        try:
            font_header = ImageFont.truetype("/usr/share/fonts/truetype/nanum/NanumSquareB.ttf", 50)
            font_title = ImageFont.truetype("/usr/share/fonts/truetype/nanum/NanumSquareB.ttf", 22)
            font_artist = ImageFont.truetype("/usr/share/fonts/truetype/nanum/NanumSquareR.ttf", 18)
        except IOError:
            print("-> 나눔 폰트가 없습니다. 기본 폰트를 사용합니다.")
            font_header, font_title, font_artist = [ImageFont.load_default()] * 3

        img = Image.new("RGB", (1024, 1280), (245, 245, 245))
        draw = ImageDraw.Draw(img)
        header_text = f"Playlist for <{movie_title}>"
        draw.text((50, 50), header_text, font=font_header, fill=(50, 50, 50))

        cols, rows = 3, 2
        padding = 50
        card_width = (img.width - padding * (cols + 1)) / cols
        card_height = (img.height - 250 - padding * (rows + 1)) / rows

        for i, track in enumerate(recommended_tracks):
            row, col = i // cols, i % cols
            x = padding + col * (card_width + padding)
            y = 200 + row * (card_height + padding)

            draw.rectangle([x, y, x + card_width, y + card_height], fill=(255, 255, 255), outline=(220, 220, 220), width=2)

            art_x, art_y = x + 20, y + 20
            art_size = card_width - 40
            try:
                album_art_url = track['album']['images'][0]['url']
                art_response = requests.get(album_art_url)
                album_art_img = Image.open(io.BytesIO(art_response.content)).resize((int(art_size), int(art_size)))
                img.paste(album_art_img, (int(art_x), int(art_y)))
            except:
                draw.rectangle([art_x, art_y, art_x + art_size, art_y + art_size], fill=(230, 230, 230))

            text_x, text_y = x + 20, art_y + art_size + 20
            title_text = track['name']
            artist_text = ", ".join([a['name'] for a in track['artists']])
            if len(title_text) > 20: title_text = title_text[:20] + "..."
            if len(artist_text) > 25: artist_text = artist_text[:25] + "..."
            draw.text((text_x, text_y), title_text, font=font_title, fill=(30, 30, 30))
            draw.text((text_x, text_y + 30), artist_text, font=font_artist, fill=(120, 120, 120))

            ui_y = y + card_height - 50
            draw.line([x + 20, ui_y, x + card_width - 20, ui_y], fill=(220, 220, 220), width=3)
            draw.polygon([(x + 120, ui_y + 15), (x + 120, ui_y + 35), (x + 140, ui_y + 25)], fill=(80, 80, 80))

        print("-> 플레이리스트 템플릿 생성 완료!")
        return img

    def run(self):
        """사용자와 상호작용하며 영화 플레이리스트와 아트워크를 생성한다."""
        movie_title = input("\n플레이리스트를 만들고 싶은 영화 제목을 입력하세요: ")
        if not movie_title:
            print("-> 영화 제목이 입력되지 않았습니다.")
            return

        overview, genres = self._get_movie_data(movie_title)
        if not overview: return

        keywords = self._get_llm_keywords(overview, genres)
        if not keywords: return

        recommended_tracks = self._recommend_music(keywords)

        print("\n✨ 최종 추천 플레이리스트 ✨")
        if not recommended_tracks:
            print("-> 추천할 만한 곡을 찾지 못했습니다.")
            return

        for i, track in enumerate(recommended_tracks):
            artist_names = ", ".join([a['name'] for a in track['artists']])
            print(f"  {i+1}. {track['name']} - {artist_names}")

        final_image = self._create_playlist_template(movie_title, recommended_tracks)
        if final_image:
            print("\n🎨 생성된 플레이리스트 이미지 🎨")
            display(final_image)

# --- 메인 실행 부분 ---
if __name__ == "__main__":
    movipl_engine = MoviPL_Visualizer()
    if movipl_engine.is_ready:
        movipl_engine.run()